using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;

namespace GoldMeridian.KeyGen.Utilities;

internal static class Extensions
{
    private const string embedded_attribute_definition =
        """
        // <auto-generated/>
        namespace Microsoft.CodeAnalysis
        {
            internal sealed partial class EmbeddedAttribute : global::System.Attribute
            {
            }
        }
        """;

    extension(IncrementalGeneratorPostInitializationContext ctx)
    {
        // Takes advantage of the fact modern versions of the compiler will
        // enforce partiality.  We're stuck on an older verison of the compiler
        // for compatibility purposes with other workflows, but we can still
        // mirror this implementation.
        // This only works for C#.
        // https://github.com/dotnet/roslyn/blob/5dd606bb21208dfc6fd3d9b07ae963a93248483b/src/Compilers/Core/Portable/SourceGeneration/IncrementalContexts.cs#L225
        public void PolyfillAddEmbeddedAttributeDefinition()
        {
            ctx.AddSource(
                "Microsoft.CodeAnalysis.EmbeddedAttribute",
                SourceText.From(embedded_attribute_definition, Encoding.UTF8)
            );
        }
    }

    extension(Accessibility)
    {
        private static int Rank(Accessibility acc)
        {
            return acc switch
            {
                Accessibility.Public => 5,
                Accessibility.Internal => 4,
                Accessibility.Protected => 3,
                Accessibility.ProtectedOrInternal => 3,
                Accessibility.ProtectedAndInternal => 2,
                Accessibility.Private => 1,
                _ => 0,
            };
        }

        public static Accessibility Min(Accessibility a, Accessibility b)
        {
            return Accessibility.Rank(a) <= Accessibility.Rank(b) ? a : b;
        }
    }

    extension(Accessibility a)
    {
        public string ToKeyword()
        {
            return a switch
            {
                Accessibility.Internal => "internal",
                Accessibility.Public => "public",
                _ => "internal", // We could do with a better fallback case.
            };
        }
    }

    extension(INamedTypeSymbol type)
    {
        public Accessibility GetEffectiveAccessibility()
        {
            var acc = type.DeclaredAccessibility;

            for (var parent = type.ContainingType; parent is not null; parent = parent.ContainingType)
            {
                acc = Accessibility.Min(acc, parent.DeclaredAccessibility);
            }

            return acc;
        }

        public bool IsUsable()
        {
            for (; type is not null; type = type.ContainingType)
            {
                if (type.DeclaredAccessibility is Accessibility.Private or Accessibility.Protected)
                {
                    return false;
                }
            }

            return true;
        }
    }
}
